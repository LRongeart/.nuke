# ____________________________________________________________________ 
# NimbyRunner - The main event loop for the NIMBY execution. In the 
#               event loop, we can check if the screen saver is running
#               and we also update the user interface with a list of
#               jobs that are currently running on the Tractor blade.
#
# ____________________________________________________________________ 
# Copyright (C) 2011 Pixar Animation Studios. All rights reserved.
#
# The information in this file is provided for the exclusive use of the
# software licensees of Pixar.  It is UNPUBLISHED PROPRIETARY SOURCE CODE
# of Pixar Animation Studios; the contents of this file may not be disclosed
# to third parties, copied or duplicated in any form, in whole or in part,
# without the prior written permission of Pixar Animation Studios.
# Use of copyright notice is precautionary and does not imply publication.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
# ____________________________________________________________________ 
#


import os
import sys
import threading
import time
import logging
import Queue
import urllib2
import getpass
import socket
import PySide.QtCore
import PySide.QtGui

# define commands used to communicate between this thread and the UI
NIMBY_OFF = "0"
NIMBY_ON = "1"
NIMBY_SCREENSAVER = "2"
AUTO_EJECT = "3"
NO_AUTO_EJECT = "4"
EJECT_JOBS = "5"
NIMBY_USERONLY = "6"

# define the number of minutes that the user can be idle
# on linux before setting the nimby value to 0
LINUX_IDLE_MINUTES = 5

import NimbyInterface
import NimbyLoginUI

from tractor.base.TrHttpRPC import TrHttpRPC

if sys.platform == "win32":
    import ctypes 
    
    class GetPoint(ctypes.Structure):
        _fields_ = [("x", ctypes.c_ulong), ("y", ctypes.c_ulong)]     
        
elif sys.platform.find("linux") > -1:
    import ctypes
    
    # from X11/extensions/scrnsaver.h
    class XScreenSaverInfo(ctypes.Structure):
        _fields_ = [("window",      ctypes.c_ulong), 
            ("state",       ctypes.c_int),   
            ("kind",        ctypes.c_int),   
            ("since",       ctypes.c_ulong), 
            ("idle",        ctypes.c_ulong), 
            ("event_mask",  ctypes.c_ulong)] 
            
    class XScreenSaverSession(object):
        def __init__(self):
            self.m_x11Lib = ctypes.cdll.LoadLibrary("libX11.so")
            self.m_display = self.m_x11Lib.XOpenDisplay(os.environ["DISPLAY"])
            if not self.m_display:
                raise Exception("Could not open the X display.")
            self.m_xRootWindow = self.m_x11Lib.XDefaultRootWindow(self.m_display)
            self.m_xssLib = ctypes.cdll.LoadLibrary("libXss.so.1")
            self.m_xssLib.XScreenSaverAllocInfo.restype = \
                ctypes.POINTER(XScreenSaverInfo)
            self.m_xssInfo = self.m_xssLib.XScreenSaverAllocInfo()
        
        def getIdleTime(self):
            self.m_xssLib.XScreenSaverQueryInfo(
                self.m_display, self.m_xRootWindow, self.m_xssInfo)
            return self.m_xssInfo.contents.idle / 1000

    
class SetNimbyError(Exception):
    def __init__(self, msg):
        self.m_msg = msg


class NimbyRunner(PySide.QtCore.QObject):
    '''
    A thread that can be used to process nimby requests
    and display the nimby UI.
    '''
    def __init__(self, options, logger, appBuild):
        apply(PySide.QtCore.QObject.__init__, (self,))
               
        self.m_log = logger        
        self.m_monitorPort = str(options.mPort)
        self.m_monitorName = options.monitor
        self.m_user = options.userName
        self.m_passwd = None      # set later
        self.m_nimbyValue = "1"
        self.m_checkForScreenSaver = False
        self.m_autoEject = False
        self.m_bladePort = options.bport
        self.m_bladeName = "localhost"
        self.resolveHostName(options.altname)
        self.m_queryInterval = options.jobquerytime
        self.m_intervalCounter = 0
        self.m_exitValue = options.onExit
        self.m_loggedIn = False
        
        # register a timer with the Qt event loop
        # that checks the blade status and screen saver status every second.
        self.m_timer = PySide.QtCore.QTimer()
        self.m_timer.timeout.connect(self.update)
        
        # set up the UI.
        self.m_outgoingCommands = Queue.Queue()
        self.m_incomingCommands = Queue.Queue()
        self.m_ui = NimbyInterface.NimbyInterface(options, appBuild,
            self.m_outgoingCommands, self.m_incomingCommands, self.m_log)

        if options.winstate == "minimize":
            # minimize the main window.
            self.m_ui.Minimize()    

        if sys.platform == "win32":
            # set up the initial mouse position, which is used
            # to determine the idle state.
            self.m_initialMouseX, self.m_initialMouseY = self.getMousePosition()

        elif sys.platform.find("linux") > -1:
            # on linux, we get the X idle time to determine
            # the idle state
            self.m_xScreenSaverInfo = XScreenSaverSession()
        
        # allow config file to override values in options
        if options.configfile:
            self.useConfigFile(options.configfile)
    
        # headers used in the connection to the blade and monitor            
        self.m_lmthdr = {
            "User-Agent": appBuild,
            "X-Tractor-Blade": "0"
        }
        self.m_xheaders = {
            "Host": "%s:%s" % (self.m_monitorName, self.m_monitorPort),
            "Cookie": "TractorUser=%s" % self.m_user
        }

        # http connection to blade
        self.m_bladeConnect = TrHttpRPC("localhost",
            int(self.m_bladePort), self.m_log, self.m_lmthdr, urlprefix="")
            
        
        # attempt to get monitor and port from the blade status
        # 
        # this also gives an initial attempt to connect to the blade
        # and will exit if unsuccessful
        # if connect is successful, AND returned data includes the
        # 'monitor' field, then use that info instead of the previously
        # set monitor and port from command-line

        try:
            self.setMonitorFromBlade()
        except Exception, e:
            return
        
        # http connection to the monitor
        self.m_monitorConnect = TrHttpRPC(self.m_monitorName, 
            int(self.m_monitorPort), self.m_log, self.m_lmthdr, timeout=3600)    

        passwordRequired = self.m_monitorConnect.PasswordRequired()
        if passwordRequired and not self.m_passwd:
            # password is global, so that it will be remembered if connection fails
            # or is restarted
            if options.passwd:  
                self.m_passwd = options.passwd
            else: 
                self.m_loginui = NimbyLoginUI.NimbyLoginUI(self.m_user)
                # give the user 3 attempts at using a valid login, then quit.
                if not self.logIn(True, ""):
                    err = "Invalid login, please try again."
                    if not self.logIn(True, err):
                        self.logIn(True, err) 
        
        if not self.m_loggedIn:
            self.logIn() 
        
    
    ## ------------------------------------------------ ##
    def logIn(self, showLoginUi=False, loginUiMessage=""):
        if showLoginUi:
            self.m_loginui.Show(loginUiMessage)
            self.m_loginui.exec_()
            self.m_user = self.m_loginui.GetName()
            self.m_passwd = self.m_loginui.GetPasswd()
                
        try:    
            self.m_tsid = self.monitorLogin(self.m_user, self.m_passwd, self.m_xheaders)
            self.m_loggedIn = True
        except Exception, e:
            errclass, excobj = sys.exc_info()[:2]
            errMsg = "Could not log in to the Tractor Monitor. %s - %s" % \
                (errclass.__name__, str(excobj))
            self.m_log.error(errMsg)
            self.m_log.error("Monitor: %s:%s" % 
                (self.m_monitorName, self.m_monitorPort))
            
            if not showLoginUi:
                PySide.QtGui.QMessageBox.critical(None, "Login Error", errMsg)       
            self.m_loggedIn = False
        
        return self.m_loggedIn
        
    ## ------------------------------------------------ ##
    def Start(self, nimbyValue):
        
        if not self.m_loggedIn:
            return False
        
        # set up the initial nimby value
        try:
            if nimbyValue == "0":
                self.setNimbyValue("0")
            elif nimbyValue == "1":
                self.setNimbyValue("1")
            elif nimbyValue == "screensaver":
                self.setNimbyValue("1")
                self.m_checkForScreenSaver = True
        except SetNimbyError:
            errMsg = "Could not set nimby value for blade: %s:%s" % \
                (self.m_bladeName, self.m_bladePort)
            self.m_log.error(errMsg)
            PySide.QtGui.QMessageBox.critical(None, "Login Error", errMsg)
            return False
                
        # start the timer, which runs the update
        # method every second.
        self.m_timerSeconds = 1
        self.m_timer.start(self.m_timerSeconds * 1000)
        
        # display the UI.
        self.m_ui.show()    
        return True    
    
    
    ## ------------------------------------------ ##
    def useConfigFile(self, configfile):
        # try to read and eval the config file
        try:
            f=open(configfile, "r")
        except:
            self.m_log.error("unable to locate config file: %s", configfile)
        try:
            data=f.read()
            f.close()
            # the config file is supposed to contain at a minumum user and password
            # info to log into the monitor. raises an exception if not defined
            configdict = eval(data)
            tractordict =  configdict["tractorconfig"]
            self.m_user = tractordict["user"]
            self.m_passwd = tractordict["passwd"]
                
            # it may also contain other config information like monitor and port
            # this we want to be careful and not raise an exception if they do not 
            # exist.  These entries are not required
            if "monitor" in tractordict:
                host,x,port = tractordict["monitor"].partition(':')
                self.m_monitorName = host
                self.m_mPort = str(port)
            if "port" in tractordict:
                port = tractordict["port"]
                self.m_mPort = str(port)
                
        except:
            self.m_log.error("config file contains invalid data: %s", 
                configfile)

            
    ## ------------------------------------------ ##    
    def monitorLogin(self, user, passwd, xheaders):
    
        # will throw an exception if Login fails
        data = self.m_monitorConnect.Login(user, passwd)
        tsid = data['tsid']     # already checked by connector
        self.m_bladeAddr = data['host']
        self.m_log.info("monitor login successful for %s:%s:%s" \
            %(user, str(tsid), self.m_bladeAddr))
        return tsid
        
    ## ------------------------------------------ ##        
    def monitorLogout(self):    
        # log out of the tractor monitor
        q = "q=logout&user="+self.m_user+"&tsid="+self.m_tsid
        err, data = self.m_monitorConnect.Transaction(
            "monitor?"+q, None, "logout", self.m_xheaders)
        self.m_log.info("code="+str(err)+" - "+repr(data))    
        self.m_loggedIn = False      
   

    ## ------------------------------------------ ##                    
    # code taken from TrSysState.py that the blade 
    # uses to find the host name.
    # nimby should find the host name the same way as the blade.
    def resolveHostName(self, altname):
        lnm = "localhost";
        try:
            lnm = socket.gethostname()
            hostname,aliases,addrs = socket.gethostbyname_ex(lnm)
            aliases.append(hostname)
            hnm = lnm.split('.')[0] 

        except Exception:
            hnm = lnm
            aliases = []
            addrs = ['127.0.0.1']

            aliases.append(hnm)

            # strip osx off-the-grid suffix
            h = hnm.rfind(".local")
            if h >= 0 and hnm.endswith(".local"):
                aliases.append( hnm )
                hnm = hnm[:h]

            try:
                h = hnm.split('.')[0]
                if h != hnm:
                    h2,al2,ad2 = socket.gethostbyname_ex(h)
                    if h2 == hnm:
                        hnm = h
                        aliases.append(h)
                        aliases.extend(al2)
                        addrs.extend(ad2)
            except Exception:
                pass

        if altname and altname != hnm:
            hnm = altname
            try:
                h2,al2,ad2 = socket.gethostbyname_ex(hnm)
                aliases.append(h2)
                aliases.extend(al2)
                addrs.extend(ad2)
            except Exception:
                pass

        self.m_bladeName = hnm

        if len(addrs) > 1:
            addrs = self.uniquifySequence(addrs)
            # remove 127.0.0.1 if there are other choices
            try:
                if len(addrs) > 1:
                    addrs.remove('127.0.0.1')
            except Exception:
                pass
        self.m_addrs = addrs

        if len(aliases) > 1:
            aliases = self.uniquifySequence(aliases)
        self.m_aliases = aliases


    ## ------------------------------------------ ##
    def uniquifySequence(self, seq):
        # Remove duplicates from the inbound sequence.
        # Does not preserve order among retained items.
        return {}.fromkeys(seq).keys()               
        

    ## ------------------------------------------ ##        
    def setNimbyValue(self, value):
    
        bladeinfo = "%s/%s:%d" % \
            (self.m_bladeName, self.m_bladeAddr, self.m_bladePort)
        err, data = self.m_monitorConnect.Transaction(
            "ctrl?q=battribute&b=%s&nimby=%s&tsid=%s" % \
            (bladeinfo, value, self.m_tsid), None, "status")

        if err:
            errorMessage = "Error while trying to set the nimby value. code="+ \
                str(err) + " - " + str(data)
            self.m_log.error(errorMessage)
            raise SetNimbyError(errorMessage)

        if data == None:
            errorMessage = "Error while trying to set the nimby value "+ \
                str(value) 
            self.m_log.error(errorMessage)
            raise SetNimbyError(errorMessage)
                    
        if data.has_key("rc") and data["rc"] != 0:
            errorMessage = "Error while trying to set the nimby value "
            if data.has_key("msg"): errorMessage += data["msg"]
            self.m_log.error(errorMessage)
            raise SetNimbyError(errorMessage)
                    
        self.m_nimbyValue = value
        self.m_log.info("set nimby status to: %s" % (value))
            
        return data


    ## ------------------------------------------ ##   
    def getMousePosition(self):
        if sys.platform == "win32":
            pt = GetPoint()
            ctypes.windll.user32.GetCursorPos(ctypes.byref(pt))

            return int(pt.x), int(pt.y)


    ## ------------------------------------------ ##        
    def screenSaverCheck(self):

        if sys.platform == "win32":
            # we are on Windows, so use the SystemParametersInfo function
            # to determine screen saver state.
            screenSaverRunning = ctypes.c_bool()
            SPI_GETSCREENSAVERRUNNING = 114
            ctypes.windll.user32.SystemParametersInfoW(SPI_GETSCREENSAVERRUNNING, 
                0, ctypes.byref(screenSaverRunning), 0) 
                
        elif sys.platform == "darwin":
            # on OSX, check if the ScreenSaverEngine process is running.
            cmd = "ps -e | grep ScreenSaverEngine | grep -v grep > /dev/null"
            result = os.system(cmd)

            if result != 256:
                screenSaverRunning = True
            else:
                screenSaverRunning = False       
        
        elif sys.platform.find("linux") > -1:
            # on linux, check the X idle time.
            # result is idle time in seconds
            result = self.m_xScreenSaverInfo.getIdleTime()
            
            if result > (60 * LINUX_IDLE_MINUTES):  # if idle for longer than 5 minutes 
                screenSaverRunning = True
            else:
                screenSaverRunning = False
          
        if screenSaverRunning: 
            # turn nimby off if needed
            if self.m_nimbyValue == "1":
                #self.m_log.info("Screen saver turned on.")
                self.setNimbyValue("0")
                
                if sys.platform == "win32":
                    # get the mouse position when the screen saver turns on
                    self.m_initialMouseX, self.m_initialMouseY = \
                        self.getMousePosition()
        else:
            # turn nimby on if needed
            if self.m_nimbyValue == "0":
                #self.m_log.info("Screen saver turned off.")
                
                if sys.platform == "win32":
                    # only turn nimby back on if the mouse has moved,
                    # because on Windows, sometimes the screen saver can
                    # turn off while the computer is still idle (when the 
                    # computer goes into a power save mode and turns the 
                    # screen off).
                    ptX, ptY = self.getMousePosition()
                
                    if ptX != self.m_initialMouseX and ptY != self.m_initialMouseY:
                        #self.m_log.info("Mouse moved and screen saver is off.")
                        self.setNimbyValue("1")
                                     
                        if self.m_autoEject:
                            self.m_log.info(
                                "Automatically ejecting active jobs.")
                            self.ejectRunningJobs()
                
                elif sys.platform == "darwin" or sys.platform.find("linux") > -1:
                    
                    self.setNimbyValue("1")
                                     
                    if self.m_autoEject:
                        self.m_log.info("Automatically ejecting active jobs.")
                        self.ejectRunningJobs()             


    ## ------------------------------------------ ##                
    def update(self):
        
        self.m_ui.ProcessQueue()
        
        # set the text box in the UI to display all
        # the running jobs
        if self.m_intervalCounter >= self.m_queryInterval:
            self.displayRunningJobs()
            self.m_intervalCounter = 0
        else:
            self.m_intervalCounter = self.m_intervalCounter + 1
            
        # process the incomming command queue set from
        # the UI thread.
        while self.m_incomingCommands.qsize():
            try:
                msg = self.m_incomingCommands.get(0)
                
                if msg == NIMBY_OFF:
                    self.setNimbyValue("0")
                    self.m_checkForScreenSaver = False
                elif msg == NIMBY_ON:
                    self.setNimbyValue("1")
                    self.m_checkForScreenSaver = False
                elif msg == NIMBY_USERONLY:
                    self.setNimbyValue(self.m_user)
                    self.m_checkForScreenSaver = False
                elif msg == NIMBY_SCREENSAVER:
                    self.setNimbyValue("1")
                    self.m_checkForScreenSaver = True
                elif msg == AUTO_EJECT:
                    self.m_autoEject = True
                    self.m_log.info("enabling auto-eject.")
                elif msg == NO_AUTO_EJECT:
                    self.m_autoEject = False
                    self.m_log.info("disabling auto-eject.")
                elif msg == EJECT_JOBS:
                    self.ejectRunningJobs()
            except Queue.Empty:
                pass
            except SetNimbyError:
                self.Stop()
        
        try:
            # if the user has selected to allow remote jobs
            # only when the screen saver is running, then
            # continually check if the screen saver is running.
            if self.m_checkForScreenSaver:
                self.screenSaverCheck()
        except SetNimbyError:
            self.Stop()
            
            
    ## ------------------------------------------ ##            
    def displayRunningJobs(self):
        pids = self.getRunningJobs()     
        if len(pids) == 0:
            # no running processes found on the blade.
            self.m_outgoingCommands.put("")
            return
        
        runningJobsText = ""
        for pid in pids:
            jid = pid["jid"]
            tid = pid["tid"]
            owner = pid["login"]
            
            jobInfo="Owner=%s, Job ID=%d, Task ID=%d" \
                % (owner, jid, tid)
                
            runningJobsText += jobInfo + "\n"
            time.sleep(.5)
        
        self.m_outgoingCommands.put(runningJobsText)     


    ## ------------------------------------------ ##            
    def ejectRunningJobs(self):
        pids = self.getRunningJobs()     
        if len(pids) == 0:
            self.m_log.info("No running processes found on the blade.")
            return

        for pid in pids:
            jid = pid["jid"]
            tid = pid["tid"]
            owner = pid["login"]
            
            command="queue?q=tretry&jid=%d&tid=%d&owner=%s&tsid=%s" \
                % (jid, tid, owner, self.m_tsid)
            
            self.m_log.info("Restart task: %d on job: %d" % (tid, jid))
            self.m_log.debug(command)
            err, data = self.m_monitorConnect.Transaction(
                command, None, "subtest", self.m_xheaders)
            
            if err:
                self.m_log.error("Could not restart task. code=" + \
                    str(err) + " - " + str(data))
            
            time.sleep(1.0)           


    ## ------------------------------------------ ##            
    def getRunningJobs(self):
        status = self.getBladeStatus()
        if status != None:
            return status["pids"]
        else:
            return ""             


    ## ------------------------------------------ ##            
    def setMonitorFromBlade(self):

        data = None
        err, data = self.m_bladeConnect.Transaction(
            "/blade/status", None, "status")

        if err:
        
            # retry the connection
            self.m_bladeConnect = TrHttpRPC(
                "localhost", int(self.m_bladePort), 
                self.m_log, self.m_lmthdr, urlprefix="")
            err, data = self.m_bladeConnect.Transaction(
                "/blade/status", None, "status")
        
            if err:
                errorMessage = "Could not connect to the blade named " + \
                self.m_bladeName + " on port " + str(self.m_bladePort) + \
                ". code="+str(err) + " - " + str(data)
                self.m_log.error(errorMessage)
                raise Exception(errorMessage)

        if data:
            if data.has_key("engine"):
                m,n,p = data['engine'].partition(":")
                self.m_monitorName = m
                self.m_monitorPort = int(p)
            # engine may have different concept of blade name
            # change to match so later battribute call wont fail
            if data.has_key("hnm"):
                self.m_bladeName = data['hnm']


    ## ------------------------------------------ ##            
    def getBladeStatus(self):
    
        data = {"pids":""}
        err, data = self.m_bladeConnect.Transaction(
            "/blade/status", None, "status")

        if err:
        
            # retry the connection
            self.m_bladeConnect = TrHttpRPC(
                "localhost", int(self.m_bladePort), 
                self.m_log, self.m_lmthdr, urlprefix="")
            err, data = self.m_bladeConnect.Transaction(
                "/blade/status", None, "status")
        
            if err:
                self.m_log.error("Could not connect to the blade named " + \
                self.m_bladeName + " on port " + str(self.m_bladePort) + \
                ". code="+str(err) + " - " + str(data))
                data = {"pids":""}

        if data == None:
            self.m_log.error("unable to get blade status: %s:%s" % \
                (self.m_bladeName,self.m_bladePort))
            data = {"pids":""}
        
        return data                        
             
             
    ## ------------------------------------------ ##    
    def Stop(self):    
        if self.m_loggedIn:
            try:
                # Reset the nimby state to the exit value.
                self.setNimbyValue(self.m_exitValue)
            except SetNimbyError:
                pass
                
            # log out of the monitor
            self.monitorLogout()
        
        self.m_ui.close() 
        
