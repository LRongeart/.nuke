# ____________________________________________________________________ 
# NimbyInterface - The user interface for NIMBY. It is created using
#                  the Tkinter module and communicates with the 
#                  NimbyRunner instance that started the UI.
#
# ____________________________________________________________________ 
# Copyright (C) 2011 Pixar Animation Studios. All rights reserved.
#
# The information in this file is provided for the exclusive use of the
# software licensees of Pixar.  It is UNPUBLISHED PROPRIETARY SOURCE CODE
# of Pixar Animation Studios; the contents of this file may not be disclosed
# to third parties, copied or duplicated in any form, in whole or in part,
# without the prior written permission of Pixar Animation Studios.
# Use of copyright notice is precautionary and does not imply publication.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
# ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
# SHALL PIXAR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES
# OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
# WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
# ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
# SOFTWARE.
# ____________________________________________________________________ 
#


import sys
import os
import Queue
import NimbyRunner
import PySide.QtGui

class NimbyInterface(PySide.QtGui.QMainWindow):
    
    def __init__(self, options, versionInfo, 
        incomingCommands, outgoingCommands, logger, *args):    
        apply(PySide.QtGui.QMainWindow.__init__, (self, ) + args)
                         
        self.m_inCommandQueue = incomingCommands
        self.m_outCommandQueue = outgoingCommands               
        self.m_log = logger
        self.m_versionInfo = versionInfo
        
        self.setWindowTitle("NIMBY")
        
        resourceDir = os.path.join(
            os.path.dirname(os.path.realpath(sys.executable)),
            "..", "lib", "Resources", "images")
        iconPath =  os.path.join(resourceDir,"nimbyIcon.png")
        self.setWindowIcon(PySide.QtGui.QIcon(iconPath))
            
        # set up the menus for the main window
        self.m_fileMenu = self.menuBar().addMenu("File")
        
        aboutAction = PySide.QtGui.QAction("About NIMBY", self)
        aboutAction.triggered.connect(self.showAboutInfo)
        self.m_fileMenu.addAction(aboutAction)
        
        exitAction =  PySide.QtGui.QAction("&Exit", self)
        exitAction.setShortcuts(PySide.QtGui.QKeySequence.Quit)
        exitAction.triggered.connect(self.close)    
        self.m_fileMenu.addAction(exitAction)
        
        # the main layout for the window
        mainLayout = PySide.QtGui.QVBoxLayout()
        
        # create radio button group box
        nimbyControls= PySide.QtGui.QGroupBox("NIMBY Controls")
        controlsLayout = PySide.QtGui.QVBoxLayout()
        nimbyControls.setLayout(controlsLayout)
        
        mainLayout.addWidget(nimbyControls)
        
        # create the radio buttons in the UI.
        self.m_radioButtonGroup = PySide.QtGui.QButtonGroup(nimbyControls)
        self.m_allowRemoteJobsButton = PySide.QtGui.QRadioButton(
            "Always allow remote jobs")
        self.m_radioButtonGroup.addButton(self.m_allowRemoteJobsButton,
            int(NimbyRunner.NIMBY_OFF))    
        self.m_privateUseButton = PySide.QtGui.QRadioButton(
            "Private use only for: " + options.userName)
        self.m_radioButtonGroup.addButton(self.m_privateUseButton,
            int(NimbyRunner.NIMBY_USERONLY))
        self.m_localUseButton = PySide.QtGui.QRadioButton(
            "Local command use only - no remote jobs")   
        self.m_radioButtonGroup.addButton(self.m_localUseButton,
            int(NimbyRunner.NIMBY_ON))    
        if sys.platform.find("linux") > -1:
            optionText = "Remote use after " + \
                str(NimbyRunner.LINUX_IDLE_MINUTES)+" minutes idle"
        else:
            optionText = "Remote use during screen saver only"
        self.m_screenSaverButton = PySide.QtGui.QRadioButton(
            optionText)    
        self.m_radioButtonGroup.addButton(self.m_screenSaverButton,
            int(NimbyRunner.NIMBY_SCREENSAVER))
        
        controlsLayout.addWidget(self.m_allowRemoteJobsButton)
        controlsLayout.addWidget(self.m_privateUseButton)
        controlsLayout.addWidget(self.m_localUseButton)
        controlsLayout.addWidget(self.m_screenSaverButton)
        
        # set up the initial nimby value
        if options.nimby == "0":
            self.m_allowRemoteJobsButton.click()
        elif options.nimby == "1":
            self.m_localUseButton.click()
        elif options.nimby == "private":
            self.m_privateUseButton.click()
        elif options.nimby == "screensaver":
            self.m_screenSaverButton.click()
        
        self.m_radioButtonGroup.buttonClicked.connect(
            self.nimbySelectionChanged)
        
        # create a checkbox to auto-eject jobs
        self.m_autoEjectCheckBox = PySide.QtGui.QCheckBox(
            "Auto-eject jobs on wake up")
        self.m_autoEjectCheckBox.setStyleSheet(
            "QCheckBox { margin-left: 20px; margin-bottom: 10px }")    
        controlsLayout.addWidget(self.m_autoEjectCheckBox)
        self.m_autoEjectCheckBox.stateChanged.connect(
            self.updateAutoEject)
                      
        # create the button to eject running jobs
        self.m_ejectButton = PySide.QtGui.QPushButton(
            "Eject Active Jobs") 
        controlsLayout.addWidget(self.m_ejectButton)
        self.m_ejectButton.clicked.connect(self.ejectRunningJobs)
             
        # create a label for the jobs text box
        jobsLabel = PySide.QtGui.QLabel("Active Jobs")
        mainLayout.addWidget(jobsLabel)
        
        # create the text box to hold running job info
        self.m_jobInfoTextBox = PySide.QtGui.QTextBrowser()
        mainLayout.addWidget(self.m_jobInfoTextBox)
        
        # a widget will hold all the other pieces for the main 
        # window.
        mainWidget = PySide.QtGui.QWidget()
        mainWidget.setLayout(mainLayout)
        self.setCentralWidget(mainWidget)
        

    ## ------------------------------------------ ##       
    def nimbySelectionChanged(self):
        selection = str(self.m_radioButtonGroup.checkedId())
        
        if selection == NimbyRunner.NIMBY_OFF:
            # Reset the blade NIMBY state to unrestricted.
            self.m_outCommandQueue.put(NimbyRunner.NIMBY_OFF)
            
        elif selection == NimbyRunner.NIMBY_USERONLY:
            # Restrict the blade to accept only local Cmds in jobs 
            # spooled from the local machine.
            self.m_outCommandQueue.put(NimbyRunner.NIMBY_USERONLY)

        elif selection == NimbyRunner.NIMBY_ON:
            # Restrict the blade to accept only local Cmds in jobs 
            # spooled from the local machine.
           self.m_outCommandQueue.put(NimbyRunner.NIMBY_ON)
        
        elif selection == NimbyRunner.NIMBY_SCREENSAVER:
            # only accept remote jobs when the screen saver is running.
            self.m_outCommandQueue.put(NimbyRunner.NIMBY_SCREENSAVER)    
    
    
    ## ------------------------------------------ ##                    
    def setText(self, text):
        self.m_jobInfoTextBox.setPlainText(text)
            
    ## ------------------------------------------ ##        
    def deleteText(self):
        self.m_jobInfoTextBox.clear()        
            
    ## ------------------------------------------ ##       
    def updateAutoEject(self):
        if self.m_autoEjectCheckBox.isChecked():
            self.m_outCommandQueue.put(NimbyRunner.AUTO_EJECT)
        else:
            self.m_outCommandQueue.put(NimbyRunner.NO_AUTO_EJECT)    
        
    ## ------------------------------------------ ##       
    def ejectRunningJobs(self):
        self.m_outCommandQueue.put(NimbyRunner.EJECT_JOBS)
        
    ## ------------------------------------------ ##       
    def ProcessQueue(self):
        while self.m_inCommandQueue.qsize():
            try:
                msg = self.m_inCommandQueue.get(0)
                
                if msg == "":
                    self.deleteText()
                else:
                    self.setText(msg)
            except Queue.Empty:
                pass
    
    ## ------------------------------------------ ##       
    def Minimize(self):
        self.showMinimized()
        
    ## ------------------------------------------------ ##
    def showAboutInfo(self):
        PySide.QtGui.QMessageBox.about(self, "About NIMBY",
            self.m_versionInfo)                            
